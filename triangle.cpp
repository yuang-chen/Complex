#include <iostream>
#include <vector>

/*
 * Triangle Counting.
 * Code Generated by GPT-4.
 * The correctness is not verified.
 */

struct CSRGraph {
  int num_vertices;
  std::vector<int> row_ptr;
  std::vector<int> col_idx;
};

int count_triangles(const CSRGraph& graph) {
  int triangle_count = 0;

  // Iterate through all vertices in the graph
  for (int u = 0; u < graph.num_vertices; ++u) {
    // Iterate through all neighbors of vertex u
    for (int i = graph.row_ptr[u]; i < graph.row_ptr[u + 1]; ++i) {
      int v = graph.col_idx[i];

      // Only consider neighbors v with greater indices to avoid duplicate
      // triangles
      if (v > u) {
        std::vector<int> common_neighbors;
        int ptr_u = graph.row_ptr[u];
        int ptr_v = graph.row_ptr[v];

        // Iterate through the neighbors of vertices u and v
        while (ptr_u < graph.row_ptr[u + 1] && ptr_v < graph.row_ptr[v + 1]) {
          int neigh_u = graph.col_idx[ptr_u];
          int neigh_v = graph.col_idx[ptr_v];

          // If u and v have a common neighbor, add it to the common_neighbors
          // vector
          if (neigh_u == neigh_v) {
            common_neighbors.push_back(neigh_u);
            ++ptr_u;
            ++ptr_v;
          }
          // If the neighbor of u has a smaller index, move to the next neighbor
          // of u
          else if (neigh_u < neigh_v) {
            ++ptr_u;
          }
          // If the neighbor of v has a smaller index, move to the next neighbor
          // of v
          else {
            ++ptr_v;
          }
        }

        // Each common neighbor forms a triangle with vertices u and v
        // Increment the triangle count by the number of common neighbors
        triangle_count += common_neighbors.size();
      }
    }
  }

  return triangle_count;
}

int main() {
  CSRGraph graph = {
      6, {0, 2, 4, 6, 8, 10, 12}, {1, 2, 0, 2, 0, 1, 3, 4, 2, 4, 3, 5}};

  int triangle_count = count_triangles(graph);
  std::cout << "Number of triangles: " << triangle_count << std::endl;

  return 0;
}
